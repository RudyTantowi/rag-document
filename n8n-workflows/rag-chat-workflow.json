{
  "name": "RAG Chat Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-chat",
      "name": "Webhook Chat",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [240, 300],
      "webhookId": "rag-chat-webhook"
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "url": "https://router.huggingface.co/hf-inference/models/sentence-transformers/all-MiniLM-L6-v2/pipeline/feature-extraction",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"inputs\": $json.body?.message || $json.message } }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "id": "huggingface-query-embedding",
      "name": "HuggingFace Query Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "1",
          "name": "HuggingFace API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse HuggingFace full response\nlet responseData = $input.item.json;\nlet embedding;\n\nconsole.log('Response type:', typeof responseData);\nconsole.log('Response keys:', Object.keys(responseData || {}));\n\n// When fullResponse is true, data is in the body property\nlet response;\nif (responseData.body) {\n  const bodyContent = responseData.body;\n  console.log('Body type:', typeof bodyContent);\n  \n  // Parse body if it's a string\n  if (typeof bodyContent === 'string') {\n    try {\n      response = JSON.parse(bodyContent);\n    } catch (e) {\n      throw new Error(`Failed to parse body string: ${e.message}. Body: ${bodyContent.substring(0, 200)}`);\n    }\n  } else {\n    response = bodyContent;\n  }\n} else {\n  response = responseData;\n}\n\nconsole.log('Parsed response type:', typeof response);\nconsole.log('Is array:', Array.isArray(response));\n\n// HuggingFace returns [[x,y,z,...]] (nested array)\nif (Array.isArray(response)) {\n  if (Array.isArray(response[0])) {\n    embedding = response[0];\n  } else if (typeof response[0] === 'number') {\n    embedding = response;\n  } else {\n    throw new Error(`Unexpected array content type: ${typeof response[0]}`);\n  }\n} else {\n  throw new Error(`Expected array response, got ${typeof response}. Keys: ${Object.keys(response || {}).join(', ')}`);\n}\n\n// Validate embedding\nif (!Array.isArray(embedding) || embedding.length === 0) {\n  throw new Error(`Invalid embedding: not an array or empty. Length: ${embedding?.length || 0}`);\n}\n\nif (typeof embedding[0] !== 'number') {\n  throw new Error(`Embedding contains non-numeric values: ${typeof embedding[0]}`);\n}\n\nconsole.log(`âœ“ Valid embedding with ${embedding.length} dimensions`);\n\nconst webhookData = $('Webhook Chat').item.json;\n\n// Format as PostgreSQL vector string '[x,y,z,...]'\nconst vectorString = `[${embedding.join(',')}]`;\n\nreturn {\n  json: {\n    embedding: vectorString,\n    file_id: webhookData.body?.file_id || webhookData.file_id,\n    message: webhookData.body?.message || webhookData.message\n  }\n};"
      },
      "id": "code-extract-embedding",
      "name": "Extract Embedding",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "url": "https://ankdhneeohlknstgloyy.supabase.co/rest/v1/rpc/match_documents",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFua2RobmVlb2hsa25zdGdsb3l5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzcxNzc4NDAsImV4cCI6MjA1Mjc1Mzg0MH0.Bkjj4tNW0-hZ4yCRuWM2FhgJ6G1W-7IhA8Iy06i1TIs"
            },
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFua2RobmVlb2hsa25zdGdsb3l5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzcxNzc4NDAsImV4cCI6MjA1Mjc1Mzg0MH0.Bkjj4tNW0-hZ4yCRuWM2FhgJ6G1W-7IhA8Iy06i1TIs"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"query_embedding\": $json.embedding, \"match_count\": 5, \"filter\": { \"file_id\": $json.file_id } } }}",
        "options": {}
      },
      "id": "supabase-search",
      "name": "Supabase Vector Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "// Format context from retrieved chunks\nconst searchResults = $input.item.json;\nconst userMessage = $('Webhook Chat').item.json.body?.message || $('Webhook Chat').item.json.message;\nconst fileId = $('Webhook Chat').item.json.body?.file_id || $('Webhook Chat').item.json.file_id;\n\n// Handle both array response and single object\nconst chunks = Array.isArray(searchResults) ? searchResults : [searchResults];\n\n// Sort chunks by index and combine text\nconst sortedChunks = chunks\n  .map(item => ({\n    text: item.chunk_text,\n    index: item.chunk_index,\n    similarity: item.similarity\n  }))\n  .sort((a, b) => a.index - b.index);\n\nconst context = sortedChunks.map(c => c.text).join('\\n\\n');\n\nconst systemPrompt = \"Anda adalah asisten AI yang membantu menjawab pertanyaan berdasarkan dokumen yang diberikan. Jawab dengan jelas dan akurat berdasarkan konteks yang tersedia. Jika informasi tidak ada dalam konteks, katakan dengan jujur bahwa Anda tidak menemukan informasi tersebut dalam dokumen.\";\n\nconst userPrompt = `Context dari dokumen:\\n${context}\\n\\nPertanyaan: ${userMessage}\\n\\nJawab berdasarkan context di atas:`;\n\nreturn [{\n  json: {\n    system_prompt: systemPrompt,\n    user_prompt: userPrompt,\n    original_message: userMessage,\n    file_id: fileId,\n    chunks_used: sortedChunks.length\n  }\n}];"
      },
      "id": "code-format-context",
      "name": "Format Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": $json.system_prompt + \"\\n\\n\" + $json.user_prompt\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 0.3,\n    \"maxOutputTokens\": 1000\n  }\n} }}",
        "options": {}
      },
      "id": "gemini-chat",
      "name": "Gemini Chat",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1340, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "2",
          "name": "Google Gemini API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract Gemini response\nconst response = $input.item.json;\nconst aiMessage = response.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';\n\nconst originalMessage = $('Format Context').item.json.original_message;\nconst fileId = $('Format Context').item.json.file_id;\nconst chunksUsed = $('Format Context').item.json.chunks_used;\n\nreturn {\n  json: {\n    message: aiMessage,\n    original_question: originalMessage,\n    file_id: fileId,\n    chunks_used: chunksUsed,\n    model: 'gemini-1.5-flash'\n  }\n};"
      },
      "id": "code-format-response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "respond-webhook-chat",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1780, 300]
    }
  ],
  "connections": {
    "Webhook Chat": {
      "main": [
        [
          {
            "node": "HuggingFace Query Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HuggingFace Query Embedding": {
      "main": [
        [
          {
            "node": "Extract Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Embedding": {
      "main": [
        [
          {
            "node": "Supabase Vector Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Vector Search": {
      "main": [
        [
          {
            "node": "Format Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context": {
      "main": [
        [
          {
            "node": "Gemini Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini Chat": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2026-01-17T00:00:00.000Z",
  "versionId": "1"
}
