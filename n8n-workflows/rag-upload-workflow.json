{
  "name": "RAG Upload Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "upload",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-upload",
      "name": "Webhook Upload",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [240, 300],
      "webhookId": "rag-upload-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Chunking text into smaller pieces\nconst text = $input.item.json.body.text || $input.item.json.text;\nconst fileId = $input.item.json.body.file_id || $input.item.json.file_id;\nconst filename = $input.item.json.body.filename || $input.item.json.filename;\n\nconst chunkSize = 1000;\nconst overlapSize = 200;\nconst chunks = [];\n\nif (!text || !fileId) {\n  throw new Error('Missing required fields: text or file_id');\n}\n\nfor (let i = 0; i < text.length; i += (chunkSize - overlapSize)) {\n  const chunkText = text.substring(i, i + chunkSize);\n  \n  if (chunkText.trim().length > 0) {\n    chunks.push({\n      file_id: fileId,\n      filename: filename,\n      chunk_index: Math.floor(i / (chunkSize - overlapSize)),\n      text: chunkText,\n      chunk_size: chunkText.length\n    });\n  }\n}\n\nconsole.log(`Created ${chunks.length} chunks for file ${fileId}`);\n\nreturn chunks.map(chunk => ({ json: chunk }));"
      },
      "id": "code-chunking",
      "name": "Code Chunking",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "url": "https://router.huggingface.co/hf-inference/models/sentence-transformers/all-MiniLM-L6-v2/pipeline/feature-extraction",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"inputs\": $json.text } }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          }
        }
      },
      "id": "huggingface-embeddings",
      "name": "HuggingFace Generate Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "1",
          "name": "HuggingFace API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse HuggingFace response and format for Supabase\nconst allChunks = $('Code Chunking').all();\nconst currentIndex = $itemIndex;\nconst chunkData = allChunks[currentIndex].json;\n\n// Get response - could be string, array, or object with data property\nlet response = $input.item.json;\nlet embedding;\n\n// Handle different response formats\nif (typeof response === 'string') {\n  // Case 1: Plain JSON string\n  try {\n    response = JSON.parse(response);\n  } catch (e) {\n    throw new Error(`Failed to parse response: ${e.message}`);\n  }\n}\n\n// Now response should be an object or array\nif (response && typeof response === 'object' && response.data) {\n  // Case 2: Response is {data: \"[-0.058, ...]\"}\n  if (typeof response.data === 'string') {\n    try {\n      embedding = JSON.parse(response.data);\n    } catch (e) {\n      throw new Error(`Failed to parse data string: ${e.message}`);\n    }\n  } else if (Array.isArray(response.data)) {\n    embedding = response.data;\n  }\n} else if (Array.isArray(response)) {\n  // Case 3: Response is [[...]] or [...]\n  if (Array.isArray(response[0])) {\n    embedding = response[0];\n  } else if (typeof response[0] === 'number') {\n    embedding = response;\n  }\n}\n\n// Validate embedding\nif (!embedding || !Array.isArray(embedding)) {\n  throw new Error(`Could not extract valid embedding array. Response type: ${typeof response}, Has data: ${response?.data !== undefined}`);\n}\n\nif (embedding.length === 0) {\n  throw new Error(`Embedding array is empty`);\n}\n\nif (typeof embedding[0] !== 'number') {\n  throw new Error(`Embedding contains non-numeric values: ${typeof embedding[0]}`);\n}\n\nconsole.log(`âœ“ Valid embedding with ${embedding.length} dimensions for chunk ${chunkData.chunk_index}`);\n\n// For Supabase pgvector, format as vector string [x,y,z,...]\nconst vectorString = `[${embedding.join(',')}]`;\n\nreturn {\n  json: {\n    file_id: chunkData.file_id,\n    filename: chunkData.filename,\n    chunk_index: chunkData.chunk_index,\n    chunk_text: chunkData.text,\n    embedding: vectorString  // Send as PostgreSQL vector string format\n  }\n};"
      },
      "id": "code-format-embeddings",
      "name": "Format for Supabase",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://ankdhneeohlknstgloyy.supabase.co/rest/v1/document_chunks",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"file_id\": $json.file_id,\n  \"filename\": $json.filename,\n  \"chunk_index\": $json.chunk_index,\n  \"chunk_text\": $json.chunk_text,\n  \"embedding\": $json.embedding\n} }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "apikey",
              "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFua2RobmVlb2hsa25zdGdsb3l5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYzMDc5MTIsImV4cCI6MjA4MTg4MzkxMn0.MrhJPOowm9lkpScMrpzXLF7gVONWcn0xhqnelLF1Q_I"
            },
            {
              "name": "Authorization",
              "value": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFua2RobmVlb2hsa25zdGdsb3l5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYzMDc5MTIsImV4cCI6MjA4MTg4MzkxMn0.MrhJPOowm9lkpScMrpzXLF7gVONWcn0xhqnelLF1Q_I"
            },
            {
              "name": "Prefer",
              "value": "return=representation"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json",
              "fullResponse": false
            }
          }
        }
      },
      "id": "supabase-store",
      "name": "Supabase Store Chunks",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "jsCode": "// Get unique file_id from the formatted chunks (before Supabase)\nconst formattedItems = $('Format for Supabase').all();\nconst fileId = formattedItems[0]?.json?.file_id;\nconst filename = formattedItems[0]?.json?.filename;\nconst totalChunks = formattedItems.length;\n\nreturn [{\n  json: {\n    file_id: fileId,\n    filename: filename,\n    total_chunks: totalChunks,\n    status: 'ready'\n  }\n}];"
      },
      "id": "code-prepare-callback",
      "name": "Prepare Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "url": "http://host.docker.internal:3000/api/webhook/complete",
        "method": "POST",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "id": "http-callback",
      "name": "Callback to Next.js",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"message\": \"File processing started\", \"file_id\": $('Webhook Upload').item.json.body.file_id || $('Webhook Upload').item.json.file_id } }}"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [460, 500]
    }
  ],
  "connections": {
    "Webhook Upload": {
      "main": [
        [
          {
            "node": "Code Chunking",
            "type": "main",
            "index": 0
          },
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code Chunking": {
      "main": [
        [
          {
            "node": "HuggingFace Generate Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HuggingFace Generate Embeddings": {
      "main": [
        [
          {
            "node": "Format for Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Supabase": {
      "main": [
        [
          {
            "node": "Supabase Store Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase Store Chunks": {
      "main": [
        [
          {
            "node": "Prepare Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Callback": {
      "main": [
        [
          {
            "node": "Callback to Next.js",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2026-01-17T00:00:00.000Z",
  "versionId": "1"
}
